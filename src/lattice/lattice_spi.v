
`timescale 1ns/1ns
// --------------------------------------------------------------------
// Netlist generated by Diamond Version 0.0.0 ipgen -n lattice_spi -lang verilog -arch ICE5LP -type serialbus -freq 24 -i2c none -i2c_general_call_enable none -i2c_wakeup_enable none -i2c_iobuffer both -i2c_rate_left 100 -i2c_rate_right 100 -i2c_addr_left 10000 -i2c_addr_right 10000 -i2c_arbitration_lost none -i2c_txrx_ready none -i2c_overrun none -i2c_general_call none -i2c_sda_input both -i2c_sda_output none -spi left -spi_slave both -spi_master none -spi_rate_left 1 -spi_rate_right 1 -spi_cs_left 1 -spi_cs_right 1 -spi_tx_ready none -spi_tx_overrun none -spi_rx_ready left -spi_rx_overrun none -spi_wakeup_enable none -spi_lsb_first none -spi_phase_adj none -spi_inv_clk none -spi_hand_shake none -spi_iobuffer both 
// >>>>>>>>>>>>>>>>>>>>>>>>> COPYRIGHT NOTICE <<<<<<<<<<<<<<<<<<<<<<<<<
// --------------------------------------------------------------------
// Copyright (c) 2013 by Lattice Semiconductor Corporation
// --------------------------------------------------------------------
//
// Permission:
//
//   Lattice Semiconductor grants permission to use this code for use
//   in synthesis for any Lattice programmable logic product.  Other
//   use of this code, including the selling or duplication of any
//   portion is strictly prohibited.
//
// Disclaimer:
//
//   This VHDL or Verilog source code is intended as a design reference
//   which illustrates how these types of functions can be implemented.
//   It is the user's responsibility to verify their design for
//   consistency and functionality through the use of formal
//   verification methods.  Lattice Semiconductor provides no warranty
//   regarding the use or functionality of this code.
//
// --------------------------------------------------------------------
//
//               Lattice Semiconductor Corporation
//               5555 NE Moore Court
//               Hillsboro, OR 97214
//               U.S.A
//
//               TEL: 1-800-Lattice (USA and Canada)
//
//               web: http://www.latticesemi.com/
//               email: techsupport@latticesemi.com
//   
// --------------------------------------------------------------------
//
//  Project:           iCE Lightning
//  File:              HardIPinit.v
//  Title:             Hard IP initialization
//  Description:       Initializes the Hard IP upon power-up or on command (IPLOAD)
//                      using data (`include file) provided by the  
//                      Module Generator tool.
//
// --------------------------------------------------------------------
//
//------------------------------------------------------------
// Notes:
//
//  Default implementation utilizes LUTs to store the Initialization Data.
//  Alternatively, an EBR structure could be utilized, trading LUTs for EBR if necessary.
//
//------------------------------------------------------------
// Development History:
//
//   __DATE__ _BY_ _REV_ _DESCRIPTION___________________________
//   05/10/13  SH  0.00  Initial Design
//   11/19/13  PY  0.00  added half cycle register and removed clk mux
//
//------------------------------------------------------------
// Dependencies:
//
// - Instantiates iCE Lightning Hard IP:  User SPI, User I2C
//
//------------------------------------------------------------
// ---------- Design Unit Header ---------- //
//----------------------------------------------------------------------------
//                                                                          --
//                         ENTITY DECLARATION                               --
//                                                                          --
//----------------------------------------------------------------------------
module lattice_spi (
    // Chip Interface
    inout wire SPI2_MISO, 
    inout wire SPI2_MOSI, 
    inout wire SPI2_SCK, 
    input wire SPI2_SCSN, 
    output wire [3:0] SPI2_MCSN, 
    // Fabric Interface
    input wire RST, 
    // Asynchronous Reset, for Init_SSM
    input wire IPLOAD, 
    // Rising Edge triggers Hard IP Configuration
    output wire IPDONE, 
    // 1: Hard IP Configuration is complete
    input wire SBCLKi, 
    // System bus interface to all 4 Hard IP blocks
    input wire SBWRi, 
    //  This bus is available when IPDONE = 1
    input wire SBSTBi, 
    input wire [7:0] SBADRi, 
    input wire [7:0] SBDATi, 
    output wire [7:0] SBDATo, 
    output wire SBACKo, 
        
    output wire [1:0] I2CPIRQ, 
    output wire [1:0] I2CPWKUP, 
    output wire [1:0] SPIPIRQ, 
    output wire [1:0] SPIPWKUP) ;
    //----------------------------------------------------------------------------
    //                                                                          --
    //                       ARCHITECTURE DEFINITION                            --
    //                                                                          --
    //----------------------------------------------------------------------------
    //------------------------------
    // INTERNAL SIGNAL DECLARATIONS: 
    //------------------------------
    // parameters (constants)
    // wires (assigns)
    wire hard_SBWRi ; 
    wire hard_SBSTBi ; 
    wire [7:0] hard_SBADRi ; 
    wire [7:0] hard_SBDATi ; 
    wire hard00_SBACKO ; 
    wire hard01_SBACKO ; 
    wire hard10_SBACKO ; 
    wire hard11_SBACKO ; 
    wire [3:0] hard_ACKs ; 
    wire SBACKo_i ; 
    wire [7:0] hard00_SBDATo ; 
    wire [7:0] hard01_SBDATo ; 
    wire [7:0] hard10_SBDATo ; 
    wire [7:0] hard11_SBDATo ; 
    wire ssm_SBWRi ; 
    wire ssm_SBSTBi ; 
    wire [7:0] ssm_SBADRi ; 
    wire [7:0] ssm_SBDATi ; 
    wire I2C2_SCLo ; 
    wire I2C2_SCLoe ; 
    wire I2C2_SCLi ; 
    wire I2C2_SDAo ; 
    wire I2C2_SDAoe ; 
    wire I2C2_SDAi ; 
    wire SPI2_SO ; 
    wire SPI2_SOoe ; 
    wire SPI2_MI ; 
    wire SPI2_MO ; 
    wire SPI2_MOoe ; 
    wire SPI2_SI ; 
    wire SPI2_SCKo ; 
    wire SPI2_SCKoe ; 
    wire SPI2_SCKi ; 
    wire SPI2_SCSNi ; 
    wire [3:0] SPI2_MCSNo ; 
    wire [3:0] SPI2_MCSNoe ; 
    // regs (always)
    reg [7:0] SBDATo_i ; 
    reg load_d1 ; 
    reg load_d2 ; 
    reg start ; 
    reg pup ; 
    reg run ; 
    reg [5:0] trans_count ; 
    reg IPDONE_i ; 
    reg sb_idle ; 
    reg strobe ; 
    reg wb_we_ix ; 
    reg wb_stb_ix ; 
    reg [7:0] wb_adr_ix ; 
    reg [7:0] wb_dat_ix ; 
    parameter num_regs = 23 ; 
    wire [7:0] init_value [0:(num_regs - 1)] ; 
    wire [7:0] init_addr [0:(num_regs - 1)] ; 
    assign init_addr[0] = 8'b0111 ; 
    assign init_addr[1] = 8'b01111 ; 
    assign init_addr[2] = 8'b01001 ; 
    assign init_addr[3] = 8'b01010 ; 
    assign init_addr[4] = 8'b01011 ; 
    assign init_addr[5] = 8'b11111111 ; 
    assign init_addr[6] = 8'b11111111 ; 
    assign init_addr[7] = 8'b11111111 ; 
    assign init_addr[8] = 8'b11111111 ; 
    assign init_addr[9] = 8'b11111111 ; 
    assign init_addr[10] = 8'b11111111 ; 
    assign init_addr[11] = 8'b11111111 ; 
    assign init_addr[12] = 8'b11111111 ; 
    assign init_addr[13] = 8'b11111111 ; 
    assign init_addr[14] = 8'b11111111 ; 
    assign init_addr[15] = 8'b11111111 ; 
    assign init_addr[16] = 8'b11111111 ; 
    assign init_addr[17] = 8'b11111111 ; 
    assign init_addr[18] = 8'b11111111 ; 
    assign init_addr[19] = 8'b11111111 ; 
    assign init_addr[20] = 8'b11111111 ; 
    assign init_addr[21] = 8'b11111111 ; 
    assign init_addr[22] = 8'b11111111 ; 
    assign init_value[0] = 8'b01000 ; 
    assign init_value[1] = 1 ; 
    assign init_value[2] = 8'b10000000 ; 
    assign init_value[3] = 8'b0 ; 
    assign init_value[4] = 23 ; 
    assign init_value[5] = 8'b11111111 ; 
    assign init_value[6] = 8'b11111111 ; 
    assign init_value[7] = 8'b11111111 ; 
    assign init_value[8] = 8'b11111111 ; 
    assign init_value[9] = 8'b11111111 ; 
    assign init_value[10] = 8'b11111111 ; 
    assign init_value[11] = 8'b11111111 ; 
    assign init_value[12] = 8'b11111111 ; 
    assign init_value[13] = 8'b11111111 ; 
    assign init_value[14] = 8'b11111111 ; 
    assign init_value[15] = 8'b11111111 ; 
    assign init_value[16] = 8'b11111111 ; 
    assign init_value[17] = 8'b11111111 ; 
    assign init_value[18] = 8'b11111111 ; 
    assign init_value[19] = 8'b11111111 ; 
    assign init_value[20] = 8'b11111111 ; 
    assign init_value[21] = 8'b11111111 ; 
    assign init_value[22] = 8'b11111111 ; 
    //-------------------------------------//
    //-- assign (non-process) operations --//
    //-------------------------------------//
    // SYSTEM BUS multiplexing
    assign hard_SBWRi = (IPDONE_i ? SBWRi : ssm_SBWRi) ; 
    assign hard_SBSTBi = (IPDONE_i ? SBSTBi : ssm_SBSTBi) ; 
    assign hard_SBADRi = (IPDONE_i ? SBADRi : ssm_SBADRi) ; 
    assign hard_SBDATi = (IPDONE_i ? SBDATi : ssm_SBDATi) ; 
    assign hard_ACKs = {hard11_SBACKO,hard10_SBACKO,hard01_SBACKO,hard00_SBACKO} ; // DATo mux selector
    assign SBACKo_i = (|hard_ACKs) ; 
    // Initialization SSM outputs
    assign ssm_SBWRi = 1 ; // All transaction are WRITE
    assign ssm_SBSTBi = strobe ; // 
    assign ssm_SBADRi = init_addr[trans_count] ; // write SBADR
    assign ssm_SBDATi = init_value[trans_count] ; //  with init data
    always
        @( hard_SBWRi)
        begin
            wb_we_ix = hard_SBWRi ;
        end
    always
        @( hard_SBSTBi)
        begin
            wb_stb_ix = hard_SBSTBi ;
        end
    always
        @( hard_SBADRi)
        begin
            wb_adr_ix = hard_SBADRi ;
        end
    always
        @( hard_SBDATi)
        begin
            wb_dat_ix = hard_SBDATi ;
        end
    //-------------------------------------//
    //---- always (process) operations ----//
    //-------------------------------------//
    // DATo mux
    //
    always
        @( hard_ACKs)
        case (hard_ACKs)
        4'b1000 : 
            SBDATo_i <=  hard11_SBDATo ;
        4'b0100 : 
            SBDATo_i <=  hard10_SBDATo ;
        4'b010 : 
            SBDATo_i <=  hard01_SBDATo ;
        4'b01 : 
            SBDATo_i <=  hard00_SBDATo ;
        default : 
            SBDATo_i <=  8'b0 ;
        endcase 
    //   Initialization SSM control: Start, Run, Done
    //
    always
        @(posedge SBCLKi or posedge RST)
        if (RST) 
            begin
                load_d1 <=  0 ;
                load_d2 <=  0 ;
                start <=  0 ;
                pup <=  1 ;
                run <=  0 ;
                trans_count <=  0 ;
                IPDONE_i <=  0 ;
            end
        else
            begin
                load_d1 <=  (IPLOAD || pup) ;
                load_d2 <=  load_d1 ;
                start <=  (load_d1 && (!load_d2)) ;// rising-edge detection
                if (start) // clear power-up launch flag
                    pup <=  0 ;
                if (start) 
                    run <=  1 ;
                else
                    // start init sequence
                    if (IPDONE_i) //  clear when init complete
                        run <=  0 ;
                if (start) 
                    begin
                        // reset control upon Start
                        trans_count <=  0 ;
                        IPDONE_i <=  0 ;
                    end
                else
                    if ((init_addr[trans_count] == 8'b11111111)) 
                        begin
                            // DONE
                            IPDONE_i <=  1 ;
                        end
                    else
                        if (SBACKo_i) 
                            begin
                                // increment if not DONE
                                trans_count <=  (trans_count + 1) ;
                            end
            end
    //  System Bus transaction control
    //    Assert stb until EFB acknowledges with SBACKo
    //
    always
        @(posedge SBCLKi or posedge RST)
        begin
            if (RST) 
                begin
                    sb_idle <=  1 ;
                    strobe <=  0 ;
                end
            else
                begin
                    //  Assert stb signals to start SB transaction
                    if (sb_idle) 
                        begin
                            if (run) 
                            // Monitor SBACKo for end of transaction
                                begin
                                    strobe <= #(1)   1 ;// delay 1 ns to avoid simulation/hardware mismatch
                                    sb_idle <=  0 ;
                                end
                        end
                    else
                        begin
                            if ((SBACKo_i | (!run))) 
                                begin
                                    strobe <=  0 ;
                                    sb_idle <=  1 ;
                                end
                        end
                end
        end
    //-------------------------------------//
    //-------- output assignments  --------//
    //-------------------------------------//
    assign SBDATo = SBDATo_i ; 
    assign SBACKo = (SBACKo_i && IPDONE_i) ; 
    assign IPDONE = IPDONE_i ; 
    assign SPI2_MISO = (SPI2_SOoe ? SPI2_SO : 1'bz) ; 
    assign SPI2_MI = SPI2_MISO ; 
    assign SPI2_MOSI = (SPI2_MOoe ? SPI2_MO : 1'bz) ; 
    assign SPI2_SI = SPI2_MOSI ; 
    assign SPI2_SCK = (SPI2_SCKoe ? SPI2_SCKo : 1'bz) ; 
    assign SPI2_SCKi = SPI2_SCK ; 
    assign SPI2_SCSNi = SPI2_SCSN ; 
    assign SPI2_MCSN[3] = (SPI2_MCSNoe[3] ? SPI2_MCSNo[3] : 1'bz) ; 
    assign SPI2_MCSN[2] = (SPI2_MCSNoe[2] ? SPI2_MCSNo[2] : 1'bz) ; 
    assign SPI2_MCSN[1] = (SPI2_MCSNoe[1] ? SPI2_MCSNo[1] : 1'bz) ; 
    assign SPI2_MCSN[0] = (SPI2_MCSNoe[0] ? SPI2_MCSNo[0] : 1'bz) ; 
    //-------------------------------------//
    //----- component instantiations ------//
    //-------------------------------------//
    assign hard01_SBDATo[7] = 1'b0 ; 
    assign hard01_SBDATo[6] = 1'b0 ; 
    assign hard01_SBDATo[5] = 1'b0 ; 
    assign hard01_SBDATo[4] = 1'b0 ; 
    assign hard01_SBDATo[3] = 1'b0 ; 
    assign hard01_SBDATo[2] = 1'b0 ; 
    assign hard01_SBDATo[1] = 1'b0 ; 
    assign hard01_SBDATo[0] = 1'b0 ; 
    assign hard01_SBACKO = 1'b0 ; 
    assign I2CPIRQ[0] = 1'b0 ; 
    assign I2CPWKUP[0] = 1'b0 ; 
    assign hard11_SBDATo[7] = 1'b0 ; 
    assign hard11_SBDATo[6] = 1'b0 ; 
    assign hard11_SBDATo[5] = 1'b0 ; 
    assign hard11_SBDATo[4] = 1'b0 ; 
    assign hard11_SBDATo[3] = 1'b0 ; 
    assign hard11_SBDATo[2] = 1'b0 ; 
    assign hard11_SBDATo[1] = 1'b0 ; 
    assign hard11_SBDATo[0] = 1'b0 ; 
    assign hard11_SBACKO = 1'b0 ; 
    assign I2CPIRQ[1] = 1'b0 ; 
    assign I2CPWKUP[1] = 1'b0 ; 
    SB_SPI #(.BUS_ADDR74("0b0000")) SB_SPI_INST_LT /* synthesis SPI_CLK_DIVIDER=23 */  (.SBCLKI(SBCLKi), .SBRWI(wb_we_ix), .SBSTBI(wb_stb_ix), .SBADRI7(wb_adr_ix[7]), .SBADRI6(wb_adr_ix[6]), .SBADRI5(wb_adr_ix[5]), .SBADRI4(wb_adr_ix[4]), .SBADRI3(wb_adr_ix[3]), .SBADRI2(wb_adr_ix[2]), .SBADRI1(wb_adr_ix[1]), .SBADRI0(wb_adr_ix[0]), .SBDATI7(wb_dat_ix[7]), .SBDATI6(wb_dat_ix[6]), .SBDATI5(wb_dat_ix[5]), .SBDATI4(wb_dat_ix[4]), 
                .SBDATI3(wb_dat_ix[3]), .SBDATI2(wb_dat_ix[2]), .SBDATI1(wb_dat_ix[1]), .SBDATI0(wb_dat_ix[0]), .MI(SPI2_MI), .SI(SPI2_SI), .SCKI(SPI2_SCKi), .SCSNI(SPI2_SCSNi), .SBDATO7(hard00_SBDATo[7]), .SBDATO6(hard00_SBDATo[6]), .SBDATO5(hard00_SBDATo[5]), .SBDATO4(hard00_SBDATo[4]), .SBDATO3(hard00_SBDATo[3]), .SBDATO2(hard00_SBDATo[2]), .SBDATO1(hard00_SBDATo[1]), 
                .SBDATO0(hard00_SBDATo[0]), .SBACKO(hard00_SBACKO), .SPIIRQ(SPIPIRQ[0]), .SPIWKUP(SPIPWKUP[0]), .SO(SPI2_SO), .SOE(SPI2_SOoe), .MO(SPI2_MO), .MOE(SPI2_MOoe), .SCKO(SPI2_SCKo), .SCKOE(SPI2_SCKoe), .MCSNO3(SPI2_MCSNo[3]), .MCSNO2(SPI2_MCSNo[2]), .MCSNO1(SPI2_MCSNo[1]), .MCSNO0(SPI2_MCSNo[0]), .MCSNOE3(SPI2_MCSNoe[3]), 
                .MCSNOE2(SPI2_MCSNoe[2]), .MCSNOE1(SPI2_MCSNoe[1]), .MCSNOE0(SPI2_MCSNoe[0])) ; 
    assign hard10_SBDATo[7] = 1'b0 ; 
    assign hard10_SBDATo[6] = 1'b0 ; 
    assign hard10_SBDATo[5] = 1'b0 ; 
    assign hard10_SBDATo[4] = 1'b0 ; 
    assign hard10_SBDATo[3] = 1'b0 ; 
    assign hard10_SBDATo[2] = 1'b0 ; 
    assign hard10_SBDATo[1] = 1'b0 ; 
    assign hard10_SBDATo[0] = 1'b0 ; 
    assign hard10_SBACKO = 1'b0 ; 
    assign SPIPIRQ[1] = 1'b0 ; 
    assign SPIPWKUP[1] = 1'b0 ; 
endmodule


