module adder_32b_param(i_a, i_b, i_carry, o_carry, o_summ);
  parameter WIDTH = 32;
  input [WIDTH-1:0] i_a, i_b;
  input i_carry;
  output [WIDTH-1:0] o_summ;
  output o_carry;
  wire [WIDTH-2:0] carry;
  wire [WIDTH-1:0] inv_b;
  wire b_inv, b_o_inv;
	
`define CSLA_ADDER_16
`ifdef RC_ADDER
  `define ADD_VERSION 0
  `ifdef CLA_ADDER
    `error_multiple_adder_definitions
  `elsif CSLA_ADDER_16
    `error_multiple_adder_definitions
  `endif
  
  // genetating ripple carry adder
  genvar i;

  generate
    for (i = 0; i < WIDTH; i = i + 1) begin
      if (i == 0)
        full_adder ints1(i_a[i], i_b[i], i_carry, o_summ[i], carry[i]);
      else if (i == WIDTH-1)
        full_adder ints1(i_a[i], i_b[i], carry[i-1], o_summ[i], o_carry);
      else 
        full_adder ints1(i_a[i], i_b[i], carry[i-1], o_summ[i], carry[i]);
    end
  endgenerate
endmodule
`endif

`ifdef CLA_ADDER
  `define ADD_VERSION 0
  `ifdef CSLA_ADDER_16
    `error_multiple_adder_definitions
  `elsif RC_ADDER
    `error_multiple_adder_definitions
  `endif
//  Verilog code for CLA(carry look ahead affer)
  wire c0,c1,c2,c3,c4,c5,c6;

  cla4 n1(i_a[3:0],i_a[3:0],cin,o_summ[3:0],c0);
  cla4 n2(i_a[7:4],i_a[7:4],c0,o_summ[7:4],c1);
  cla4 n3(i_a[11:8],i_a[11:8],c1,o_summ[11:8],c2);
  cla4 n4(i_a[15:12],i_a[15:12],c2,o_summ[15:12],c3);
  cla4 n5(i_a[19:16],i_a[19:16],c3,o_summ[19:16],c4);
  cla4 n6(i_a[23:20],i_a[23:20],c4,o_summ[23:20],c5);
  cla4 n7(i_a[27:24],i_a[27:24],c5,o_summ[27:24],c6);
  cla4 n8(i_a[31:28],i_a[31:28],c6,o_summ[31:28],cout);

endmodule
`endif

`ifdef CSLA_ADDER_16
  `define ADD_VERSION 20
  `ifdef CLA_ADDER
    `error_multiple_adder_definitions
  `elsif RC_ADDER
    `error_multiple_adder_definitions
  `endif

  wire csla_16_carry;
	//carry_select_adder_16bit(a, b, cin, sum, cout);
  carry_select_adder_16bit inst_csla_16_l (.a(i_a[15:0]), .b(i_b[15:0]), .cin(1'b0), .sum(o_summ[15:0]), .cout(csla_16_carry));
  carry_select_adder_16bit inst_csla_16_h (.a(i_a[31:16]), .b(i_b[31:16]), .cin(csla_16_carry), .sum(o_summ[31:16]), outcarry1);
endmodule
`endif

//////////////////////////////////////
//4-bit Carry Select Adder Slice
//////////////////////////////////////
 
module carry_select_adder_4bit_slice(a, b, cin, sum, cout);
  input [3:0] a,b;
  input cin;
  output [3:0] sum;
  output cout;
  
  wire [3:0] s0,s1;
  wire c0,c1;

  ripple_carry_4_bit rca1(
                          .a(a[3:0]),
                          .b(b[3:0]),
                          .cin(1'b0),
                          .sum(s0[3:0]),
                          .cout(c0)
                          );
  
  ripple_carry_4_bit rca2(
                          .a(a[3:0]),
                          .b(b[3:0]),
                          .cin(1'b1),
                          .sum(s1[3:0]),
                          .cout(c1)
                          );
  
  mux2X1 #(4) ms0(
                  .in0(s0[3:0]),
                  .in1(s1[3:0]),
                  .sel(cin),
                  .out(sum[3:0])
                  );
  
  mux2X1 #(1) mc0(
                  .in0(c0),
                  .in1(c1),
                  .sel(cin),
                  .out(cout)
                  );

endmodule
  
/////////////////////
//2X1 Mux
/////////////////////
 
module mux2X1(in0, in1, sel, out);
  parameter WIDTH=16; 
  input [WIDTH-1:0] in0, in1;
  input sel;
  output [WIDTH-1:0] out;
  assign out = (sel) ? in1 : in0;
endmodule
 
/////////////////////////////////
//4-bit Ripple Carry Adder
/////////////////////////////////
module ripple_carry_4_bit(a, b, cin, sum, cout);
  input [3:0] a,b;
  input cin;
  output [3:0] sum;
  output cout;
 
  wire c1,c2,c3;
  
  full_adder fa0(a[0],b[0],cin,sum[0],c1);
  
  full_adder fa1(
                a[1],
                b[1],
                c1,
                sum[1],
                c2
                );
  
  full_adder fa2(
                a[2],
                b[2],
                c2,
                sum[2],
                c3
                );
  
  full_adder fa3(
                a[3],
                b[3],
                c3,
                sum[3],
                cout
                );

  endmodule
module carry_select_adder_16bit(a, b, cin, sum, cout);
  input [15:0] a,b;
  input cin;
  output [15:0] sum;
  output cout;
  
  wire [2:0] c;
  
  ripple_carry_4_bit rca1(
  .a(a[3:0]),
  .b(b[3:0]),
  .cin(cin),
  .sum(sum[3:0]),
  .cout(c[0]));
  
  // first 4-bit by ripple_carry_adder
  carry_select_adder_4bit_slice csa_slice1(
  .a(a[7:4]),
  .b(b[7:4]),
  .cin(c[0]),
  .sum(sum[7:4]),
  .cout(c[1]));
  
  carry_select_adder_4bit_slice csa_slice2(
  .a(a[11:8]),
  .b(b[11:8]),
  .cin(c[1]),
  .sum(sum[11:8]), 
  .cout(c[2]));
  
  carry_select_adder_4bit_slice csa_slice3(
  .a(a[15:12]),
  .b(b[15:12]),
  .cin(c[2]),
  .sum(sum[15:12]),
  .cout(cout));
endmodule

module cla4(a,b,cin,s,cout);
  input [3:0] a,b;
  input cin;
  output cout;
  output [3:0] s;

  wire [3:0] g,p;
  wire [13:0] z;

    xor21 x1 (.a1(a[0]),.a2(b[0]),.z(p[0]));
    and21 x2 (.a1(a[0]),.a2(b[0]),.z(g[0]));
    xor21 x3 (.a1(a[1]),.a2(b[1]),.z(p[1]));
    and21 x4 (.a1(a[1]),.a2(b[1]),.z(g[1]));
    xor21 x5 (.a1(a[2]),.a2(b[2]),.z(p[2]));
    and21 x6 (.a1(a[2]),.a2(b[2]),.z(g[2]));
    xor21 x7 (.a1(a[3]),.a2(b[3]),.z(p[3]));
    and21 x8 (.a1(a[3]),.a2(b[3]),.z(g[3]));
    xor21 x9 (.a1(cin),.a2(p[0]),.z(s[0]));
    and21 x10 (.a1(cin),.a2(p[0]),.z(z[0]));
    or21 x11 (.a1(z[0]),.a2(g[0]),.z(z[1]));
    xor21 x12 (.a1(z[1]),.a2(p[1]),.z(s[1]));
    and31 x13 (.a1(cin),.a2(p[0]),.a3(p[1]),.z(z[2]));
    and21 x14 (.a1(g[0]),.a2(p[1]),.z(z[3]));
    or31 x15 (.a1(z[2]),.a2(z[3]),.a3(g[1]),.z(z[4]));
    xor21 x16 (.a1(z[4]),.a2(p[2]),.z(s[2]));
    and41 x17 (.a1(cin),.a2(p[0]),.a3(p[1]),.a4(p[2]),.z(z[5]));
    and31 x18 (.a1(g[0]),.a2(p[1]),.a3(p[2]),.z(z[6]));
    and21 x19 (.a1(g[1]),.a2(p[2]),.z(z[7]));
    or41 x20 (.a1(z[5]),.a2(z[6]),.a3(z[7]),.a4(g[2]),.z(z[8]));
    xor21 x21 (.a1(z[8]),.a2(p[3]),.z(s[3]));
    and41 x22 (.a1(cin),.a2(p[0]),.a3(p[1]),.a4(p[2]),.z(z[9]));
    and31 x23 (.a1(g[0]),.a2(p[1]),.a3(p[2]),.z(z[10]));
    and21 x24 (.a1(g[1]),.a2(p[2]),.z(z[11]));
    or41 x25 (.a1(z[9]),.a2(z[10]),.a3(z[11]),.a4(g[2]),.z(z[12]));
    and21 x26 (.a1(z[12]),.a2(p[3]),.z(z[13]));
    or21 x27 (.a1(z[13]),.a2(g[3]),.z(cout));
endmodule

module full_adder(i_a, i_b, i_carry, o_sum, o_carry);
  input i_a, i_b, i_carry;
  output o_sum, o_carry;
  wire sum1, carry1, carry2;
  
  half_adder inst1(i_a, i_b, sum1, carry1);
  half_adder inst2(sum1, i_carry, o_sum, carry2);
  or inst3(o_carry, carry1, carry2);
 
endmodule

module half_adder(i_a, i_b, o_sum, o_carry);
  input i_a, i_b;
  output o_sum, o_carry;
  
  and inst1(o_carry, i_a, i_b);
  xor inst2(o_sum, i_a, i_b);  
  
endmodule


